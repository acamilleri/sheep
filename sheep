#!/bin/bash

set -e

#
# Shortcut for log_info function
#
# $* - Text to log
#
log() {
	log_info $*
}

#
# Log text in file specified by the environment variable
# SHEEP_LOG_FILE when log level level is ERROR or INFO
#
# $* - Text to log
#
log_info() {
	_log INFO $*
}

#
# Log text in file specified by the environment variable
# SHEEP_LOG_FILE when log level level is ERROR or INFO
#
# $* - Text to log
#
log_warning() {
	_log WARNING $*
}

#
# Log text in file specified by the environment variable
# SHEEP_LOG_FILE (always)
#
# $* - Text to log
#
log_error() {
	_log ERROR $*
}

#
# Log text in file specified by the environment variable
# SHEEP_LOG_FILE when log level level is DEBUG
#
# $* - Text to log
#
log_debug() {
	_log DEBUG $*
}

#
# Internal function for logging. The one that actually do logging
#
# $1 - Log severity (i.e. ERROR, WARNING, INFO or DEBUG)
# $* - Text to log
#
_log() {
	#
	# Log file to log into
	#
	if [ -z "${SHEEP_LOG_FILE}" ]; then
		SHEEP_LOG_FILE="/tmp/sheep-$(date +%s).log"
	fi
	touch ${SHEEP_LOG_FILE}

	#
	# Authorized log level are ERROR, WARNING, INFO and DEBUG
	#
	if [ -z "${SHEEP_LOG_LEVEL}" ]; then
		SHEEP_LOG_LEVEL=INFO
	fi

	local severity="${1}"

	if [ "${severity}" = 'ERROR' ]; then
		:
	elif [ "${severity}" = 'WARNING' ]; then
		if [[ "${SHEEP_LOG_LEVEL}" = "ERROR" ]]; then
			return
		fi
	elif [ "${severity}" = 'DEBUG' ]; then
		if [ "${SHEEP_LOG_LEVEL}" != "DEBUG" ]; then
			return
		fi
	else
		#
		# If severity is equals to something else, the only one remaining authorized value is 'INFO',
		# so we force this value. It is equivalent to have a fallback value to INFO when the value is unknown
		#
		severity=INFO
		if [[ "${SHEEP_LOG_LEVEL}" = "ERROR" || "${SHEEP_LOG_LEVEL}" = "WARNING" ]]; then
			return
		fi
	fi

	{
		printf "$(date '+[%D %T %z]') %-7s | " ${severity}
		shift
		echo "$*"
	} >> $SHEEP_LOG_FILE
}

#
# $1 - Error message
#
exit_on_error() {
	log_debug "-> ${FUNCNAME[0]} $*"

	echo "ERROR : $1" >&2
	log "Exit with status code 1"
	exit 1
}

#
# Configuration map populated when search_value is called the first time.
#
declare -A configMap

#
# search_value returns the value matching a given parameter identifier.
# if the parameter is not defined or if its value is blank, it returns
# a default value if provided.
#
# When the function is called the first time it populate the `configMap``
# variable parsing the commande line parameter.
#
# By default, parameters are retrieved from the kernel command line
# reading /proc/cmdline content. This can be overriden by setting up
# the SHEEP_PARAMETERS environment variable with the exact same
# syntax.
#
# $1 - Parameter identifier
# $2 - Default value
#
search_value() {
	log_debug "-> ${FUNCNAME[0]} $*"

	if [ ${#configMap[@]} -eq 0 ]; then
		local cmd=${SHEEP_PARAMETERS}
		if [ -z "${cmd}" ]; then
			cmd=$(cat /proc/cmdline)
		fi

		IFS=' ' read -r -a array <<< "${cmd}"
		for param in ${array[@]}; do
			local key=$(echo "${param}" | cut -d '=' -f 1)
			local value=$(echo "${param}" | cut -d '=' -f 2-)
			configMap[${key}]=${value}
		done
	fi
	if [ "${1}" == "sheep.config" ]; then
		local value=${configMap[${1}]}
	else
		local value=$(yq -r $1 ${CONFIG_FILE})
		if [ ${value} == "null" ]; then
			value=""
		fi
	fi
	echo ${value:-${2}}
}

#
# $1 - key
# $2 - error message if the value is not found
#
search_mandatory_value() {
	log_debug "-> ${FUNCNAME[0]} $*"

	local value=$(yq -r $1 ${CONFIG_FILE})

	[ "${value}" == "null" ] && exit_on_error "$2"
	log "Mandatory value for '$1' found => '${value}'"
	echo "${value}"
}

#
# This function prepare the environment by downloading tools required by the code for installation, parser yaml for variables implementation
#
prepare_env() {
	log_debug "-> ${FUNCNAME[0]} $*"

	### Workaround for Debian repos issue when runnning GRML
	###     E: The repository 'http://security.debian.org testing/updates Release' does not have a Release file.
	### We don't need this package repository so we delete it
	cat <<- 'EOF' > /etc/apt/sources.list.d/debian.list
		deb     http://snapshot.debian.org/archive/debian/20181230/ testing main contrib non-free
		deb-src http://snapshot.debian.org/archive/debian/20181230/ testing main contrib non-free
	EOF

	# Downloading of paquet needed to parse YAML configuration file
	apt update
	log_debug "apt-update return : $?"
	apt install -y python-pip
	log_debug "apt install python-pip return : $?"
	apt install -y python-setuptools
	log_debug "apt install python-setuptools return : $?"
	pip install wheel
	log_debug "apt install wheel return : $?"
	apt install -y jq
	log_debug "apt install jq return : $?"
	pip install yq
	log_debug "apt install yq return : $?"
}

load_config() {
	log_debug "-> ${FUNCNAME[0]} $*"

	local CONFIG_FILE_PATH=$(search_value sheep.config)
	if [ -z ${CONFIG_FILE_PATH} ]; then
		exit_on_error "Configuration file is missing"
	fi
	CONFIG_FILE=$(mktemp -d)/config
	wget --quiet -O ${CONFIG_FILE} ${CONFIG_FILE_PATH}
	log_debug "downloading of config file by wget return : $?"
}

#
# Create every variable needed by calling search_value or search_mandatory_value
#
config_variable() {
	log_debug "-> ${FUNCNAME[0]} $*"

	OS_NAME=$(search_value ".linux.label" "linux")
	PUBLIC_IFACE_NAME=$(search_mandatory_value ".network.interface" "'intName' parameter must be provided")
	local ret=$?
	if [ ${ret} -ne 0 ]; then
		exit ${ret}
	fi
	CLOUD_INIT_ENABLED=$(search_value ".cloudInit.enable" "false")
	BLOCK_DEVICE=$(search_value ".linux.device" $(ls /dev/[hs]d[a-z] | head -1))
	EFI_PARTITION="${BLOCK_DEVICE}1"
	CIDATA_PARTITION="${BLOCK_DEVICE}2"
	CIDATA_PARTITION_SIZE=100M
	LINUX_PARTITION="${BLOCK_DEVICE}3"
	BOOT_MODE=$([ -d /sys/firmware/efi ] && echo uefi || echo legacy)
	if [ "${BOOT_MODE}" == "legacy" ]; then
		CODE_PARTITIONNING_BOOT=ef02
		BOOT_PARTITION_SIZE=2M
	elif [ "${BOOT_MODE}" == "uefi" ]; then
		EFI_ARCHIVE_URL=$(search_mandatory_value .bootloader.image "'.bootloader.image' parameter must be provided")
		local ret=$?
		if [ ${ret} -ne 0 ]; then
			exit ${ret}
		fi
		CODE_PARTITIONNING_BOOT=ef00
		BOOT_PARTITION_SIZE=500M
	else
		exit_on_error "Boot mode '${BOOT_MODE}' is not supported"
	fi
	PXE_PILOT_ENABLED=$(search_value ".pxePilot.enable" "false")
	if [ "${PXE_PILOT_ENABLED}" == "true" ]; then
		PXE_PILOT_BASEURL="$(search_mandatory_value .pxePilot.url \"'.pxePilot.url' parameter must be provided\")"
		local ret=$?
		if [ ${ret} -ne 0 ]; then
			exit ${ret}
		fi
		PXE_PILOT_CFG=$(search_value ".pxePilot.config_after_reboot" "local")
	fi
	LINUX_ROOTFS_URL=$(search_mandatory_value ".linux.image" "'.linux.image' parameter must be provided")
	local ret=$?
	if [ ${ret} -ne 0 ]; then
		exit ${ret}
	fi
	EFI_ENTRY_LABEL="${OS_NAME}"
	CODE_PARTITIONNING=8300
	KERNEL_PARAMETER=$(search_value ".bootloader.kernel_parameter")
	SELINUX=$(search_value ".linux.selinux" "disable")
	ROOTFS_LABEL=$(search_value ".linux.rootfsLabel" "rootfs")
	check_filesystem_label ${ROOTFS_LABEL}
	ROOTFS_TYPE=$(search_value ".linux.rootfsType" "ext4")
	REBOOT_WHEN_DONE=$(search_value ".sheep.reboot" "true")
}

#
# Check if the config file match the following requirements :
#   * Less than 12 characters
#   * Characters allowed [0-9],[a-z],'-','_'
#
# $1 - Root filesystem label
#
check_filesystem_label() {
	local size=${#1}
	local count=0
	if [ ${size} -gt 12 ]; then
		exit_on_error "Number of caracter exceed maximal sie : 12 caracters max"
	fi
	if [[ "$1" =~ ([0-9A-Za-z_-]{$size}) ]]; then
		:
	else
		exit_on_error "Invalid caracter used in the name given to filesystem : caracters must be a number, a letter '_' or '-'"
	fi
}

#
# Create two partitions on the drive. One system EFI partition to install
# the bootloader nad on for the Linux root filesystem. If some partitions
# previoulsly exist on the drive everything is wiped beforehand.
#
system_partitionning() {
	log_debug "-> ${FUNCNAME[0]} $*"

	echo ' '
	echo 'Partitioning'
	echo ' '

	gdisk ${BLOCK_DEVICE} <<- EOF
		o
		Y
		n
		1

		+${BOOT_PARTITION_SIZE}
		${CODE_PARTITIONNING_BOOT}
		yes
		n
		2

		+${CIDATA_PARTITION_SIZE}
		${CODE_PARTITIONNING}
		n
		3


		${CODE_PARTITIONNING}
		wq
		yes
	EOF
}

partitions_formating() {
	log_debug "-> ${FUNCNAME[0]} $*"

	if [ "${BOOT_MODE}" == "uefi" ]; then
		mkfs.fat -F 32 -n EFI ${EFI_PARTITION}
	fi

	mkfs.fat -F 32 -n cidata ${CIDATA_PARTITION}

	if [ "${ROOTFS_TYPE}" == "ext4" ]; then
		mkfs.ext4 -q -L ${ROOTFS_LABEL} ${LINUX_PARTITION} <<- EOF
			y
		EOF
	elif [ "${ROOTFS_TYPE}" == "btrfs" ]; then
		mkfs.btrfs -f -q -L ${ROOTFS_LABEL} ${LINUX_PARTITION}
	else
		exit_on_error "Filesystem type '${FILE_SYSTEM_TYPE}' unknown or not supported"
	fi
}

#
# This function check whether a string value
# reprensents a `true` boolean value or not
#
# $1 - string value representing a boolean
#
isTrue() {
	if [ "${1,,}" = 'true' ]; then
		return 0
	fi
	return 1
}

#
# Create a directory : rootfs
# Mounts the root file system partition on this one
# Create two directories in it : boot and inside efi
# Mounts efi partition on efi directory
#
partitions_mounting() {
	log_debug "-> ${FUNCNAME[0]} $*"

	if [ -e ${rootfs} ]; then
		rm -rf ${rootfs}
	fi
	mkdir ${rootfs}
	mount ${LINUX_PARTITION} ${rootfs}
	if [ "${BOOT_MODE}" == "uefi" ]; then
		mkdir -p ${rootfs}/boot/efi
		mount ${EFI_PARTITION} ${rootfs}/boot/efi
	fi
	mkdir -p ${cloudfs}
	rm -rf ${cloudfs}/*
	mount ${CIDATA_PARTITION} ${cloudfs}
}

#
# Download the file containing the root file system in /tmp directory and named it as linux_rootfs.
#
# The type supported are archive compressed like .tar.gz and .tar.xz, squashfs, qcow2.
#
# Analyses the type of root file system file and call function for extracting and copying the file system depending on the type.
#
linux_rootfs_installation() {
	log_debug "-> ${FUNCNAME[0]} $*"

	linux_image_dir=/mnt/image
	linux_image=/tmp/linux-rootfs

	wget --quiet -O ${linux_image} ${LINUX_ROOTFS_URL}

	if [ -e ${linux_image_dir} ]; then
		rm -rf ${linux_image_dir}
	fi

	mkdir ${linux_image_dir}

	if [ -n "$(file ${linux_image} | grep XZ)" ]; then
		archiveTar_installation "xfJ"
	elif [ -n "$(file ${linux_image} | grep gzip)" ]; then
		archiveTar_installation "xzf"
	elif [ -n "$(file ${linux_image} | grep Squashfs)" ]; then
		rm -rf ${linux_image_dir}
		squashfs_installation
	elif [ -n "$(file ${linux_image} | grep QCOW)" ]; then
		qcow2_installation
	elif [ -n "$(file ${linux_image} | grep ISO)" ]; then
		: #TODO : call functioninstallation for iso root fs
	fi
}

archiveTar_installation() {
	log_debug "-> ${FUNCNAME[0]} $*"

	(
		cd ${linux_image_dir}
		tar ${1} ${linux_image}
	)
	cp -rp ${linux_image_dir}/* ${rootfs}
}

squashfs_installation() {
	log_debug "-> ${FUNCNAME[0]} $*"

	unsquashfs -d ${linux_image_dir} ${linux_image}
	cp -rp ${linux_image_dir}/* ${rootfs}
}

qcow2_installation() {
	log_debug "-> ${FUNCNAME[0]} $*"

	DEBIAN_FRONTEND=noninteractive apt install -y libguestfs-tools

	guestmount -a ${linux_image} -m /dev/sda1 ${linux_image_dir}

	cp -rp ${linux_image_dir}/* ${rootfs}

	umount ${linux_image_dir}
}

bootloader_installation() {
	log_debug "-> ${FUNCNAME[0]} $*"

	if [ "${BOOT_MODE}" == "uefi" ]; then
		bootloader_installation_uefi
	elif [ "${BOOT_MODE}" == "legacy" ]; then
		grub-install --root-directory=${rootfs} ${BLOCK_DEVICE}
	fi
}

bootloader_installation_uefi() {
	log_debug "-> ${FUNCNAME[0]} $*"
	local bootloader_name=ubuntu # bootloader_name is used to name the bootloader folder
	# in the EFI partition. For now, it have to be 'ubuntu' and
	# can't be changed as long we rely on Grub EFI comming from
	# Cannonical because some paths are harcoded into binaries.

	local bootloader_dir=${rootfs}/boot/efi/EFI/${bootloader_name}
	local bootloader_archive_file=/tmp/efi.tar.gz

	wget --quiet -O ${bootloader_archive_file} ${EFI_ARCHIVE_URL}
	tar xvzf ${bootloader_archive_file} -C ${rootfs}/boot/efi
	rm -f ${bootloader_archive_file}
	cat <<- EOF > ${bootloader_dir}/grub.cfg
		search --label ${ROOTFS_LABEL} --set
		set prefix=(\$root)'/boot/grub2'
		configfile \$prefix/grub.cfg
	EOF

	efibootmgr -c -d ${BLOCK_DEVICE} -p 1 -L "${EFI_ENTRY_LABEL}" -l "\EFI\\${bootloader_name}\shimx64.efi"
}

# This function is useful to erase unecessary efi boot entry
#
# - Unecessary boot entry are those which have been added with a path to the bootloader
# - Permit to avoid bug after reboot
efi_entry_cleanup() {
	log_debug "-> ${FUNCNAME[0]} $*"

	num=$(efibootmgr -v | grep "File" | cut -d ' ' -f 1 | grep "0" | cut -d 't' -f 2 | cut -d '*' -f 1)
	N=$(echo $num | wc -w)
	for i in $(seq 1 $N); do
		entry=$(echo $num | cut -d ' ' -f $i)
		efibootmgr -b $entry -B
	done
}

configure_fstab() {
	log_debug "-> ${FUNCNAME[0]} $*"

	cat <<- EOF > ${rootfs}/etc/fstab
		LABEL=${ROOTFS_LABEL} /                       ${ROOTFS_TYPE}     defaults        0 0
	EOF

	if [ "${BOOT_MODE}" == "uefi" ]; then
		cat <<- EOF >> ${rootfs}/etc/fstab
			LABEL=EFI             /boot/efi               vfat     defaults        0 0
		EOF
	fi
	cat <<- EOF >> ${rootfs}/etc/fstab
		LABEL=cidata                           vfat     defaults        0 0
	EOF
}

config_metadata_ci_disable() {
	log_debug "-> ${FUNCNAME[0]} $*"

	local instanceId=$(search_value ".cloudInit.instance_id")
	local localHostname=$(search_value ".environment.local_hostname")
	local networkProtocol=$(search_value ".network.mode" "dhcp")

	cat <<- EOF > ${cloudfs}/meta-data
		instance-id: ${instanceId}
		local-hostname: ${localHostname}
		network:
		  version: 2
		  ethernets:
		    ${PUBLIC_IFACE_NAME}:
	EOF
	if [ ${networkProtocol} == "dhcp" ]; then
		cat <<- EOF >> ${cloudfs}/meta-data
			      dhcp4: true
		EOF
	elif [ ${networkProtocol} == "static" ]; then
		local address=$(search_value ".network.adress")
		local gateway=$(search_value ".network.gateway")
		cat <<- EOF >> ${cloudfs}/meta-data
			      adresses:
			        - ${address}
			      gateway4: ${gateway}
		EOF
	fi
}

config_userdata_ci_disable() {
	log_debug "-> ${FUNCNAME[0]} $*"

	local c=0
	local user=$(yq -r .environment.users[$c] ${CONFIG_FILE})
	local name=$(search_value ".environment.users[$c].name")
	local sudoer=$(search_value ".environment.users[$c].sudoer")
	local ssh=$(search_value ".environment.users[$c].ssh_authorized_key")

	cat <<- EOF > ${cloudfs}/user-data
		#cloud-config
		users:
	EOF
	while [ "${user}" != "null" ]; do
		name=$(search_value ".environment.users[$c].name")
		sudoer=$(search_value ".environment.users[$c].sudoer")
		ssh=$(search_value ".environment.users[$c].ssh_authorized_key")
		cat <<- EOF >> ${cloudfs}/user-data
			  - name: ${name}
			    lock_passwd: false
		EOF
		echo "    ssh_authorized_keys: ${ssh}" >> ${cloudfs}/user-data
		if [ ${sudoer} == "true" ]; then
			echo "    sudo: ALL=(ALL) NOPASSWD:ALL" >> ${cloudfs}/user-data
		fi
		c=$(($c + 1))
		user=$(yq -r .environment.users[$c] ${CONFIG_FILE})
	done
	cat <<- EOF >> ${cloudfs}/user-data
		chpasswd:
		  expire: false
		  list : |
	EOF
	N=$(($c - 1))
	for i in $(seq 0 $N); do
		local name=$(search_value ".environment.users[$i].name")
		local password=$(search_value ".environment.users[$i].password")
		echo "    ${name}:${password}" >> ${cloudfs}/user-data
	done
	cat <<- EOF >> ${cloudfs}/user-data
		ssh_pwauth: true
	EOF
}

config_metadata_ci_enable() {
	log_debug "-> ${FUNCNAME[0]} $*"

	head -$(grep -n "userData:" ${CONFIG_FILE} | cut -d ':' -f 1) ${CONFIG_FILE} | tail -$(($(head -$(grep -n "userData:" ${CONFIG_FILE} | cut -d ':' -f 1) ${CONFIG_FILE} | wc -l) - $(grep -n "metaData:" ${CONFIG_FILE} | cut -d ':' -f 1))) | grep -v "userData" | sed -e "s/^    //g" >> ${cloudfs}/meta-data
}

config_userdata_ci_enable() {
	log_debug "-> ${FUNCNAME[0]} $*"

	echo "#cloud-config" > ${cloudfs}/user-data
	head -$(($(grep -n ^"sheep" ${CONFIG_FILE} | cut -d ':' -f 1) - 2)) ${CONFIG_FILE} | tail -$(($(($(grep -n ^"sheep" ${CONFIG_FILE} | cut -d ':' -f 1) - 2)) - $(grep -n userData ${CONFIG_FILE} | cut -d ':' -f 1))) | sed -e "s/^    //g" >> ${cloudfs}/user-data
}

configure_environment() {
	log_debug "-> ${FUNCNAME[0]} $*"

	if isTrue "${CLOUD_INIT_ENABLED}"; then
		log " cloud-init config | Configure meta-data file"
		config_metadata_ci_enable

		log " cloud-init config | Configure user-data file"
		config_userdata_ci_enable
	else
		log " cloud-init config | Configure meta-data file"
		config_metadata_ci_disable

		log " cloud-init config | Configure user-data file"
		config_userdata_ci_disable
	fi
}

blacklist_module() {
	log_debug "-> ${FUNCNAME[0]} $*"

	local i=0
	local mod=$(yq -r .linux.blacklist_module[$i] ${CONFIG_FILE})
	while [ "${mod}" != "null" ]; do
		echo "blacklist ${mod}" >> ${rootfs}/etc/modprobe.d/blacklist.conf
		i=$(($i + 1))
		mod=$(yq -r .linux.blacklist_module[$i] ${CONFIG_FILE})
	done
}

linux_rootfs_configuration() {
	log_debug "-> ${FUNCNAME[0]} $*"

	log "Configuring Linux | Configure partitions mount in /etc/fstab"
	configure_fstab

	log "Configuring Linux | Configure GRUB bootloader"
	rootfs_bootloader_configuration

	log "Configuring Linux | Configure Cloud-init"
	configure_environment

	log "Configuring Linux | Blacklist modules"
	blacklist_module
}

#
# Verification of grub.cfg file presence
# Existing grub.cfg file is used to check the path to the kernel an initrd file
# These paths are used to recreate a new grub.cfg file
#
rootfs_bootloader_configuration() {
	log_debug "-> ${FUNCNAME[0]} $*"

	local grubFile=${rootfs}/boot/grub2/grub.cfg
	local legacyGrubFile=${rootfs}/boot/grub/grub.cfg

	if [ -e ${grubFile} ]; then
		cp ${grubFile} ${grubFile}.bak
		if [ ${BOOT_MODE} == "legacy" ] && [ ! -e ${legacyGrubFile} ]; then
			(cd ${rootfs}/boot/grub2 && ln -s ./../grub2/grub.cfg ./../grub/grub.cfg)
		fi
	else
		if [ ! -e ${legacyGrubFile} ]; then
			exit_on_error "Unable to locate GRUB config file"
		fi
		mkdir -p ${rootfs}/boot/grub2/
		cp ${legacyGrubFile} ${grubFile}
		mv ${legacyGrubFile} ${legacyGrubFile}.bak
		(cd ${rootfs}/boot/grub && ln -s ../grub2/grub.cfg .)
	fi

	local kernel=$(grep -o -m 1 -e 'linux\(16\)*\s*[^/]*/boot/[^ ]*' ${grubFile} | sed -e's#.*\(/boot/.*\)#\1#')
	local initrd=$(grep -o -m 1 -e 'initrd\(16\)*\s*[^/]*/boot/[^ ]*' ${grubFile} | sed -e's#.*\(/boot/.*\)#\1#')

	if [[ -z "${kernel}" || -z ${initrd} ]]; then
		# TODO Handle files in /mnt/boot/loader/entries/ for Fedora
		# e.g. /mnt/boot/loader/entries/f241772f3e32496c92975269b5794615-5.0.9-301.fc30.x86_64.conf
		:
		if [[ -z "${kernel}" || -z ${initrd} ]]; then
			exit_on_error "Can't find kernel or initrd file path"
		fi
	fi

	cat <<- EOF > ${grubFile}
		default=0
		timeout=5

		menuentry '${OS_NAME}' {
			insmod gzio
			search --label ${ROOTFS_LABEL} --set
			linux  ${kernel} root=LABEL=${ROOTFS_LABEL} ro ${KERNEL_PARAMETER} ds=nocloud
			initrd ${initrd}
		}
	EOF
}

#
# This function disable the SElinux service in the configuration file by default
# If selinux variable is set to enable, it create the file .autorelabel on root : selinux uses extended attributes
# and by copying the rootfile system this way, it comes to a problem on it
#
# So SElinux is locking everyfing. You can't log after reboot.
# Having the file .autorelabel after reboot involves two reboots before beeing able to login.
# At the first reboot, the presence of .autorelabel launch the relabelling of all files.
# Then the system reboot and you're able to login.
#
SElinux_configuration() {
	log_debug "-> ${FUNCNAME[0]} $*"

	local config_file=${rootfs}/etc/selinux/config
	if [ -e ${config_file} ]; then
		if [ "${SELINUX}" == "enable" ]; then
			touch ${rootfs}/.autorelabel
		else
			sed -i -e 's/SELINUX=enforcing/SELINUX=disabled/' ${config_file}
		fi
	fi
}

partitions_unmounting() {
	log_debug "-> ${FUNCNAME[0]} $*"

	cd /
	umount -R ${rootfs}
	umount ${cloudfs}
}

notify_pxepilot_and_reboot() {
	log_debug "-> ${FUNCNAME[0]} $*"

	macA=$(ip address | grep -A 1 "${PUBLIC_IFACE_NAME}" | grep "link/ether" | cut -d ' ' -f 6)
	if [ "${PXE_PILOT_ENABLED}" == "true" ]; then
		curl -i -X PUT "${PXE_PILOT_BASEURL}/v1/configurations/${PXE_PILOT_CFG}/deploy" -d '{"hosts":[{"macAddress":"'"$macA"'"}]}'
	fi

	# Marker to indicate installation is successful
	touch /var/run/sheep.success

	if [ "${REBOOT_WHEN_DONE}" == "true" ]; then
		reboot
	fi
}

main() {
	log_debug "-> ${FUNCNAME[0]} $*"

	log "Starting installation process"

	rootfs=/mnt/rootfs
	cloudfs=/mnt/cloudfs

	log "Preparing tools required for installation"
	prepare_env

	log "Download configuration file"
	load_config

	log "Reading input configuration"
	config_variable

	log "Cleaning local boot EFI entries from the EFI Boot Manager"
	if [ "${BOOT_MODE}" == "uefi" ]; then
		efi_entry_cleanup
	fi

	log "Erasing drive an creating the partition table"
	system_partitionning

	log "Formating partitions"
	partitions_formating

	log "Mount partition in read-write mode"
	partitions_mounting

	log "Installing Linux root filesystem into the Linux partition"
	linux_rootfs_installation

	log "Installing bootloader"
	bootloader_installation

	log "Configuring Linux"
	linux_rootfs_configuration

	log "Configuring SELinux if present"
	SElinux_configuration

	log "Unmounting partitions"
	partitions_unmounting

	log "Installation complete. Notify PXE Pilot and reboot system"
	notify_pxepilot_and_reboot
}

if [ "$(basename $0)" = "sheep" ]; then
	set -x
	main 2>&1 | tee /var/log/sheep.log
fi
